---
title: "eatATA - Automatisierte Blockbesetzung"
author: "Benjamin Becker"
format: revealjs
editor: visual
---

## Theoretischer Hintergrund: Begrifflichkeiten

- **Item**  
  → Eine Frage (kleinste Einheit)
- **Aufgabe/Unit**  
  → Set von Items mit gemeinsamen Stimulus
- **Block/Cluster**  
  → Zusammenstellung von Aufgaben, meist als fixer Kontext, ca. 20 Minuten
- **Testform/Testheft**  
  → Zusammenstellung von Blöcken, eine Person bearbeitet eine Testform


## Theoretischer Hintergrund: Parallele Testformen

**Wieso?**

- **Low-stakes Assessments**  
  → Breite inhaltliche Abdeckung  
  → Messgenauigkeit auf Gruppenebene

- **High-stakes Assessments**  
  → Abschreiben/Betrugsversuche verhindern  
  → Weitergabe Testinhalte verhindern

- **Pilotierungen**  
  → Testung großer Itemzahlen

## Theoretischer Hintergrund: Block vs. Testform

**Anforderungen Blockbesetzung**  

- Parallelität (inhaltlich, Formate, ...)

**Anforderungen Testformen**

- Parallelität
- Linking

## Theoretischer Hintergrund: IQB-Anwendungen

**Blockbesetzung**  

- Bildungstrend
- VERA Module
- (Prä)-Pilotierungen  
  → Bildungstrend  
  → VERA
  
## Theoretischer Hintergrund: Parallele Blöcke

**Hinsichtlich?**

- Inhaltliche Bereiche
- Aufgabenformate
- Schwierigkeit/Testinformation
- Itemunverträglichkeiten
- Zeitaufwand/Speededness
- ...

## Theoretischer Hintergrund: Blockbesetzung

**Bisher zumeist händisch via Excel, aber:**

- viele Items
- viele Constraints  
  → z.B. viele Unverträglichkeiten
- hoher Aufwand/kognitiver Load!

## Mathematical Programming: Definition

**Synonyme**

- Mathematical Optimization
- Linear Programming/Mixed Integer Programming

**Grundidee:**

Maximierungs- oder Minimierungsproblem, wobei Lösungsraum durch (Ung-)Gleichungen eingeschränkt werden kann

## Mathematical Programming: Zentrale Konzepte

**Branch and Bound Algorithmen**

- Grundidee: Probieren aller möglichen Lösungen ("Brute Forcing")
- Effiziente Reduktion des Lösungsraumes
- Kombinieren von Constraints

## Mathematical Programming: Zentrale Konzepte

- Decision Variables
- Constraints
- Objective Function

## Mathematical Programming: Beispiel

**Beispiel: Produzentenproblem**

- Anstellungsoptionen StuMis, Docs, Postdocs
- Maximal 8 Büroplätze
- Max. Kosten 120\$: StuMis (5\$), Docs (18\$), Postdocs (25\$)
- Es braucht von jeder Statusgruppe mindestens 2 Personen
- Publikationen: StuMis (1), Docs (2), Postdocs (3)
- Anzahl der Publikationen maximieren

**Frage:** Welche Kombination aus Personen soll eingestellt werden?

## Mathematical Programming: Beispiel (Fortsetzung)

**Decision Variables:**

- Anstellungsoptionen **S**tuMis, **D**ocs, **P**ostdocs

**Constraints:**

- Maximal 8 Büroplätze  
  \( S + D + P \leq 8 \)
- Max. Kosten 120\$: StuMis (5\$), Docs (18\$), Postdocs (25\$)  
  \( 5S + 18D + 25P \leq 120 \)
- Es braucht von jeder Statusgruppe mindestens 2 Personen  
  \( S \geq 2 \), \( D \geq 2 \), \( P \geq 2 \)

**Objective Function:**

- Publikationen: StuMis (1), Docs (2), Postdocs (3)
- Anzahl der Publikationen maximieren  
  Maximieren: \( 1S + 2D + 3P \)

## Mathematical Programming: Solver

**Open Source**

- lpSolve
- GLPK
- Symphony
- ...

**Komerziell**

- Gurobi
- CPLEX
- ...

## Automatisierte Testhefterstellung

```{r}
#| echo: false
knitr::include_graphics("Graphs/vanderLinden_cover.JPG")
```


## Automatisierte Testhefterstellung

::: {.block}
### Automated Test Assembly (ATA)

Verwendet Konzepte der Mathematical Optimization (Mixed Integer Programming) zur Blockbesetzung [@vanderLinden.2005]
:::

**Zentrale Konzepte**

- Decision Variables (0/1, Item x Block)
- Constraints (Testspezifikationen)
- Objective Function (wichtigste relative Testspezifikation)

## Minimalbeispiel: Item Pool

**Item Pool**

- 30 Items
- Item Formate (MC, offen, Zuordnung)
- Durchschnittliche Antwortzeiten
- Schwierigkeitsparameter (1PL-Modell)

## Minimalbeispiel: Item Pool Tabelle

```{r}
#| echo: false
# LaTeX table generated using xtable package in R.
library(knitr)
kable(data.frame(
  item = 1:5,
  format = c("mc", "mc", "mc", "mc", "mc"),
  time = c(27.79, 15.45, 31.02, 29.87, 23.13),
  difficulty = c(-1.88, 0.84, 1.12, 0.73, -0.49),
  IIF_0 = c(0.11, 0.45, 0.33, 0.5, 0.61)
), caption = "First 5 Items of the Simulated Item Pool.")
```


## Minimalbeispiel: Spezifikationen

**Spezifikationen**

- 1 Block
- Minimale durchschnittliche Blockzeit
- Exakt 10 Items im Block
- Durchschnittliche Schwierigkeit von ca. 0 (logit-Skala)


## Minimalbeispiel: Decision Variables

**Decision Variables**

- Matrix mit Spalten = Anzahl Items (+ 1) und Zeilen = Anzahl Blöcke
- 30 Items, 1 Block  
  \( i_{1, b1}, i_{2, b1}, i_{3, b1}, \ldots, i_{30, b1} \)
  
## Minimalbeispiel: Objective Function

**Objective Function**

- 'Relative Testspezifikation'
- so viel/wenig/nah wie möglich (an) ...
- Wichtig: Exakt eine Testspezifikation muss hierfür ausgewählt werden
- Min/Max/Minimax/Maximin
- Minimale Blockzeit  
  minimiere \( 27.79i_{1, b1} + 15.45i_{2, b1} + \ldots + 19.50i_{30, b1} \)

## Minimalbeispiel: Constraints

**Constraints**

- Alle anderen Testspezifikationen
- Genau 10 Items pro Block  
  \( i_{1, b1} + i_{2, b1} + \ldots + i_{30, b1} = 10 \)
- Durchschnittliche Schwierigkeit  
  \( 0.11i_{1, b1} + 0.45i_{2, b1} + \ldots + i_{30, b1} \leq 0.1 \)  
  \( 0.11i_{1, b1} + 0.45i_{2, b1} + \ldots + i_{30, b1} \geq -0.1 \)

# Umsetzung in eatATA

## eatATA

Developed with feedback from:
- Pauline Kohrt (VERA 3 Math)
- Simone Dubiel (VERA 8 German)
- Karoline Sachse (BT)

Package Authors:
- Dries Debeer (KU Leuven)
- Benjamin Becker (IQB)

## eatATA: Resources I

Vignettes available on CRAN:  
<https://CRAN.R-project.org/package=eatATA>

## eatATA: Resources II

eatATA Tutorial Paper:  
<https://doi.org/10.3390/psych3020010>

![eatATA Tutorial Paper](Graphs/psych_paper.PNG)


## Code: Objective Function

Minimize average block time:

```{r}
Btime <- minObjective(
	nForms = 1, 
	itemValues = items_mini$time,
	itemIDs = items_mini$item
)
```



## Code: Constraint 1

Specify number of items per block:

```{r}
Blength <- itemsPerFormConstraint(
	nForms = 1, 
	operator = "=",
	targetValue = 10,
	itemIDs = items_mini$item
)
```


## Code: Constraint 2

Specify average difficulty:

```{r}
Bdiff <- itemValuesRangeConstraint(
	nForms = 1, 
	itemValues = items_mini$difficulty, 
	range = c(-0.1, 0.1), 
	itemIDs = items_mini$item
)
```


## Code: Solver Call

Execute the solver:

```{r}
solver_out <- useSolver(
	list(Btime, Blength, Bdiff),
	solver = "GLPK"
)
```


## Code: Inspect Solution

Inspect the assembled block:

```{r}
inspectSolution(
	solver_out, 
	items = items_mini, 
	idCol = "item"
)
```


## Code: Append Solution

Add block allocation to item pool:

```{r}
item_mini_out <- appendSolution(
	solver_out, 
	items = items_mini, 
	idCol = "item"
)
```

## Item Inclusions

Reasons:
- Shared stimulus ('task')
- Other reasons

Implementation:
- Tasks, not items, as assembling unit (e.g., VERA 3 Math)
- Explicit item inclusions (see eatATA Tutorial)

## Item Exclusions

Reasons:
- Item contains information that could reveal another item's solution
- Items are too similar
- ...

Implementation:
- Explicit item exclusions


## Code: Item Inclusions (Input)

Input: Column with grouping information:

```{r}
incluTup <- stemInclusionTuples(
	items_lsa, 
	idCol = "item", 
	stemCol = "testlet"
)
```


## Code: Item Inclusions (Constraints)

Creating inclusion constraints:

```{r}
incluCons <- itemInclusionConstraint(
	nForms = 8,  
	itemTuples = incluTup,
	itemIDs = items_lsa$item
)
```


## Code: Item Exclusions (Input)

Input: Column with exclusion listings:

```{r}
exclusionTuples <- itemTuples(
	items_pilot, 
	idCol = "item",
	infoCol = "exclusions", 
	sepPattern = ", "
)
```


## Code: Item Exclusions (Constraints)

Creating exclusion constraints:

```{r}
excl_constraints <- itemExclusionConstraint(
	nForms = nForms,
	itemTuples = exclusionTuples, 
	itemIDs = items_pilot$item
)
```

## 

\begin{center}
\begin{LARGE}
**Thank you for your attention!**
\end{LARGE}
\end{center}
